<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Movie Bingo</title>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect } = React;

        const MovieBingo = () => {
          const defaultSquares = [
            "Someone says 'I have a bad feeling about this'",
            "Character eats pizza",
            "Car chase scene",
            "Dramatic rain scene",
            "Wilhelm scream",
            "Someone running in slow motion",
            "Explosion without looking back",
            "Montage with upbeat music",
            "FREE SPACE",
            "Phone dies at crucial moment",
            "False jump scare",
            "Character wakes from nightmare",
            "Coffee shop meet-cute",
            "Hacking completed in 30 seconds",
            "'We've got company'",
            "Breaking glass",
            "Heroic sacrifice",
            "Post-credits scene",
            "Someone checks behind shower curtain",
            "Protagonist catches falling object",
            "Mirror reveals someone behind",
            "One last job before retirement",
            "Clumsy but lovable character",
            "Villain monologue",
            "Countdown timer"
          ];

          const [title, setTitle] = useState("ðŸŽ¬ Movie Bingo ðŸŽ¬");
          const [bingoSquares, setBingoSquares] = useState(defaultSquares);
          const [marked, setMarked] = useState(new Array(25).fill(false));
          const [winningLine, setWinningLine] = useState(null);
          const [isEditing, setIsEditing] = useState(false);
          const [editTitle, setEditTitle] = useState(title);
          const [editSquares, setEditSquares] = useState([...bingoSquares]);
          const [backgroundImage, setBackgroundImage] = useState("");
          const [editBackgroundImage, setEditBackgroundImage] = useState("");
          const [gridSize, setGridSize] = useState(5);
          const [editGridSize, setEditGridSize] = useState(5);
          const [centerSquareColor, setCenterSquareColor] = useState("#fbbf24");
          const [editCenterSquareColor, setEditCenterSquareColor] = useState("#fbbf24");

          // Load from localStorage on mount
          useEffect(() => {
            try {
              const saved = localStorage.getItem('bingo-config');
              if (saved) {
                const config = JSON.parse(saved);
                setTitle(config.title);
                setBingoSquares(config.squares);
                setBackgroundImage(config.background || "");
                setGridSize(config.gridSize);
                setCenterSquareColor(config.centerColor);
                setMarked(new Array(config.squares.length).fill(false));
              }
            } catch (error) {
              console.log('No saved data found, using defaults');
            }
          }, []);

          const toggleSquare = (index) => {
            const newMarked = [...marked];
            newMarked[index] = !newMarked[index];
            setMarked(newMarked);
            checkForBingo(newMarked);
          };

          const checkForBingo = (currentMarked) => {
            const size = gridSize;
            
            for (let i = 0; i < size; i++) {
              if (currentMarked.slice(i * size, i * size + size).every(val => val)) {
                setWinningLine(`row-${i}`);
                return;
              }
            }

            for (let i = 0; i < size; i++) {
              let colComplete = true;
              for (let row = 0; row < size; row++) {
                if (!currentMarked[row * size + i]) {
                  colComplete = false;
                  break;
                }
              }
              if (colComplete) {
                setWinningLine(`col-${i}`);
                return;
              }
            }

            let diag1Complete = true;
            for (let i = 0; i < size; i++) {
              if (!currentMarked[i * size + i]) {
                diag1Complete = false;
                break;
              }
            }
            if (diag1Complete) {
              setWinningLine('diag-1');
              return;
